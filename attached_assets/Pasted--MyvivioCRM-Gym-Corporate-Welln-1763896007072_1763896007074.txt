# ============================================================
# MyvivioCRM - Gym & Corporate Wellness Management System
# Versão Híbrida (B2C/B2B) com IA, Automação/Workflow, Painel e Contratos
# Pronto para Replit
# ============================================================

from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import FileResponse
from sqlalchemy import create_engine, Column, Integer, String, Float, Boolean, ForeignKey, DateTime, Text
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, Session
from datetime import datetime, timedelta, timezone
from typing import Optional, List
import jwt
from passlib.context import CryptContext
import os
import pandas as pd
from sklearn.linear_model import LogisticRegression
import pickle
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pydantic import BaseModel, Field
import json

# ============================================================
# Configurações básicas
# ============================================================

DATABASE_URL = "sqlite:///./gym_wellness.db"
SECRET_KEY = os.getenv("SESSION_SECRET", "gym_wellness_secret_key_CHANGE_IN_PRODUCTION")
ALGORITHM = "HS256"

pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")
security = HTTPBearer()

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ============================================================
# Modelos de Banco de Dados (SQLAlchemy)
# ============================================================

class Unidade(Base):
    __tablename__ = "unidades"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String, unique=True)
    endereco = Column(String)
    # Refatoração B2C/B2B: Tipo de Unidade
    tipo_unidade = Column(String, default="B2C") # B2C (Academia/Studio) ou B2B (Corporativo)
    modelo_churn = Column(Text, nullable=True) 
    risco_desistencia = Column(Float, default=0.0) # Risco de Churn da Unidade (B2C) ou Risco de Não Renovação (B2B)
    usuarios = relationship("Usuario", back_populates="unidade")
    programas = relationship("Programa", back_populates="unidade")
    contratos = relationship("Contrato", back_populates="unidade")

class Usuario(Base):
    __tablename__ = "usuarios"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True)
    senha = Column(String)
    nome = Column(String)
    tipo = Column(String) # admin, instrutor, cliente
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    ativo = Column(Boolean, default=True)
    data_cadastro = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    ultima_atividade = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    risco_churn = Column(Float, default=0.0) 
    unidade = relationship("Unidade", back_populates="usuarios")
    agendas = relationship("Agenda", back_populates="usuario")
    jornadas = relationship("UsuarioJornada", back_populates="usuario")

class Lead(Base):
    __tablename__ = "leads"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String)
    email = Column(String)
    telefone = Column(String)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    data_contato = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    convertido = Column(Boolean, default=False)
    lead_score = Column(Integer, default=0) 
    # Refatoração B2C/B2B: Tipo de Lead
    tipo_lead = Column(String, default="Individual") # Individual (B2C) ou Corporativo (B2B)
    empresa = Column(String, nullable=True) # Nome da empresa para Leads Corporativos
    unidade = relationship("Unidade")

class Contrato(Base):
    __tablename__ = "contratos"
    id = Column(Integer, primary_key=True, index=True)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    nome = Column(String)
    data_inicio = Column(DateTime)
    data_fim = Column(DateTime)
    valor_mensal = Column(Float)
    limite_usuarios = Column(Integer, nullable=True) # Para B2B
    status = Column(String, default="Ativo") # Ativo, Expirado, Pendente
    unidade = relationship("Unidade", back_populates="contratos")

# Modelos de Automação (Jornada e Workflow) - Mantidos
class EventoAula(Base):
    __tablename__ = "eventos_aulas"
    id = Column(Integer, primary_key=True, index=True)
    nome_aula = Column(String)
    data_hora = Column(DateTime)
    limite_inscricoes = Column(Integer)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    reservas = relationship("ReservaAula", back_populates="evento_aula")

class ReservaAula(Base):
    __tablename__ = "reservas_aulas"
    id = Column(Integer, primary_key=True, index=True)
    evento_aula_id = Column(Integer, ForeignKey("eventos_aulas.id"))
    usuario_id = Column(Integer, ForeignKey("usuarios.id"))
    data_reserva = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    cancelada = Column(Boolean, default=False)
    evento_aula = relationship("EventoAula", back_populates="reservas")
    usuario = relationship("Usuario")

class EventoSistema(Base):
    __tablename__ = "eventos_sistema"
    id = Column(Integer, primary_key=True, index=True)
    tipo = Column(String)
    payload = Column(Text)
    data_registro = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    processado = Column(Boolean, default=False)

class Jornada(Base):
    __tablename__ = "jornadas"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String, unique=True)
    gatilho_evento = Column(String)
    ativa = Column(Boolean, default=True)
    etapas = relationship("EtapaJornada", back_populates="jornada", order_by="EtapaJornada.ordem")

class EtapaJornada(Base):
    __tablename__ = "etapas_jornada"
    id = Column(Integer, primary_key=True, index=True)
    jornada_id = Column(Integer, ForeignKey("jornadas.id"))
    nome = Column(String)
    ordem = Column(Integer)
    acao_tipo = Column(String)
    acao_config = Column(Text)
    jornada = relationship("Jornada", back_populates="etapas")

class UsuarioJornada(Base):
    __tablename__ = "usuarios_jornadas"
    id = Column(Integer, primary_key=True, index=True)
    usuario_id = Column(Integer, ForeignKey("usuarios.id"))
    jornada_id = Column(Integer, ForeignKey("jornadas.id"))
    etapa_atual_id = Column(Integer, ForeignKey("etapas_jornada.id"), nullable=True)
    data_inicio = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    concluida = Column(Boolean, default=False)
    usuario = relationship("Usuario", back_populates="jornadas")
    jornada = relationship("Jornada")
    etapa_atual = relationship("EtapaJornada")

# Outros modelos (Programa, Agenda, MetricaEngajamento, etc.) seriam mantidos aqui.

# ============================================================
# Schemas Pydantic
# ============================================================

class Token(BaseModel):
    access_token: str
    token_type: str

class UsuarioBase(BaseModel):
    email: str
    nome: str
    tipo: str
    unidade_id: int
    ativo: Optional[bool] = True

class UsuarioCreate(UsuarioBase):
    senha: str

class UsuarioInDB(UsuarioBase):
    id: int
    data_cadastro: datetime
    risco_churn: float

    class Config:
        from_attributes = True

class UnidadeBase(BaseModel):
    nome: str
    endereco: str
    tipo_unidade: str = Field(default="B2C", description="B2C ou B2B")

class UnidadeCreate(UnidadeBase):
    pass

class UnidadeInDB(UnidadeBase):
    id: int
    risco_desistencia: float

    class Config:
        from_attributes = True

class LeadCreate(BaseModel):
    nome: str
    email: str
    telefone: str
    unidade_id: int
    tipo_lead: str = Field(default="Individual", description="Individual ou Corporativo")
    empresa: Optional[str] = None

class ContratoCreate(BaseModel):
    unidade_id: int
    nome: str
    data_inicio: datetime
    data_fim: datetime
    valor_mensal: float
    limite_usuarios: Optional[int] = None

class ContratoInDB(ContratoCreate):
    id: int
    status: str
    class Config:
        from_attributes = True

# Schemas de Automação (Jornada e Etapa) - Mantidos
class JornadaBase(BaseModel):
    nome: str
    gatilho_evento: str = Field(..., description="Evento que inicia a jornada (ex: USUARIO_CRIADO)")
    ativa: Optional[bool] = True

class JornadaCreate(JornadaBase):
    pass

class JornadaInDB(JornadaBase):
    id: int
    class Config:
        from_attributes = True

class EtapaJornadaBase(BaseModel):
    nome: str
    ordem: int
    acao_tipo: str = Field(..., description="Tipo de ação (ex: ENVIAR_EMAIL, CRIAR_TAREFA)")
    acao_config: dict = Field(..., description="Configuração JSON da ação")

class EtapaJornadaCreate(EtapaJornadaBase):
    pass

class EtapaJornadaInDB(EtapaJornadaBase):
    id: int
    jornada_id: int
    class Config:
        from_attributes = True

# ============================================================
# Funções de Utilitário e Dependências - Mantidas
# ============================================================

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=30)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise HTTPException(status_code=401, detail="Credenciais inválidas")
        token_data = TokenData(email=email)
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Credenciais inválidas")
    
    user = db.query(Usuario).filter(Usuario.email == token_data.email).first()
    if user is None:
        raise HTTPException(status_code=401, detail="Usuário não encontrado")
    return user

def get_admin_user(current_user: Usuario = Depends(get_current_user)):
    if current_user.tipo != "admin":
        raise HTTPException(status_code=403, detail="Acesso negado. Requer privilégios de administrador.")
    return current_user

async def enviar_email(destinatario: str, assunto: str, corpo: str):
    # Função de e-mail mantida
    smtp_host = os.getenv("SMTP_HOST", "smtp.gmail.com")
    smtp_port = int(os.getenv("SMTP_PORT", "587"))
    smtp_user = os.getenv("SMTP_USER", "noreply@myvivio.com")
    smtp_pass = os.getenv("SMTP_PASSWORD", "")
    
    message = MIMEMultipart()
    message["From"] = smtp_user
    message["To"] = destinatario
    message["Subject"] = assunto
    message.attach(MIMEText(corpo, "html"))
    
    try:
        if smtp_pass:
            await aiosmtplib.send(
                message,
                hostname=smtp_host,
                port=smtp_port,
                username=smtp_user,
                password=smtp_pass,
                start_tls=True
            )
            return True
        return False
    except Exception as e:
        print(f"Erro ao enviar e-mail: {e}")
        return False

def registrar_evento(db: Session, tipo: str, payload: dict):
    evento = EventoSistema(
        tipo=tipo,
        payload=json.dumps(payload)
    )
    db.add(evento)
    db.commit()
    db.refresh(evento)
    return evento

# ============================================================
# Lógica de IA/ML (Previsão de Churn)
# ============================================================

def treinar_modelo_churn(db: Session, unidade_id: int):
    # Lógica de treinamento de modelo de churn (mantida)
    usuarios = db.query(Usuario).filter(Usuario.unidade_id == unidade_id).all()
    
    data = []
    for u in usuarios:
        dias_inatividade = (datetime.now(timezone.utc) - u.ultima_atividade).days
        reservas_canceladas = db.query(ReservaAula).filter(
            ReservaAula.usuario_id == u.id,
            ReservaAula.cancelada == True
        ).count()
        
        churn = 1 if dias_inatividade > 60 and reservas_canceladas > 5 else 0
        
        data.append({
            'dias_inatividade': dias_inatividade,
            'reservas_canceladas': reservas_canceladas,
            'churn': churn,
            'usuario_id': u.id
        })
    
    if not data or len(data) < 10:
        return "Dados insuficientes para treinamento."

    df = pd.DataFrame(data)
    X = df[['dias_inatividade', 'reservas_canceladas']]
    y = df['churn']
    
    model = LogisticRegression()
    model.fit(X, y)
    
    modelo_serializado = pickle.dumps(model)
    unidade = db.query(Unidade).get(unidade_id)
    unidade.modelo_churn = modelo_serializado.decode('latin1')
    db.commit()
    
    return "Modelo treinado e salvo com sucesso."

def prever_risco_churn(db: Session, usuario: Usuario):
    # Lógica de previsão de risco de churn (mantida)
    unidade = db.query(Unidade).get(usuario.unidade_id)
    if not unidade or not unidade.modelo_churn:
        return 0.0

    try:
        model = pickle.loads(unidade.modelo_churn.encode('latin1'))
    except:
        return 0.0

    dias_inatividade = (datetime.now(timezone.utc) - usuario.ultima_atividade).days
    reservas_canceladas = db.query(ReservaAula).filter(
        ReservaAula.usuario_id == usuario.id,
        ReservaAula.cancelada == True
    ).count()
    
    risco = model.predict_proba([[dias_inatividade, reservas_canceladas]])[0][1]
    
    usuario.risco_churn = risco
    db.commit()
    
    if risco > 0.75:
        registrar_evento(db, "CHURN_ALERTA", {"usuario_id": usuario.id, "risco": risco})
        
    return risco

# ============================================================
# Lógica de Automação e Fluxo de Trabalho (Workflow) - Mantida
# ============================================================

async def executar_acao_workflow(db: Session, usuario: Usuario, etapa: EtapaJornada):
    config = json.loads(etapa.acao_config)
    
    if etapa.acao_tipo == "ENVIAR_EMAIL":
        assunto = config.get("assunto", "Notificação MyvivioCRM")
        corpo = config.get("corpo", "Mensagem automática.")
        
        corpo = corpo.replace("{usuario_nome}", usuario.nome).replace("{usuario_email}", usuario.email)
        
        await enviar_email(usuario.email, assunto, corpo)
        return True
        
    elif etapa.acao_tipo == "CRIAR_TAREFA":
        print(f"Ação: Tarefa '{config.get('titulo', 'Tarefa de Acompanhamento')}' criada para {usuario.nome}")
        return True
        
    elif etapa.acao_tipo == "MUDAR_STATUS":
        novo_status = config.get("status")
        if novo_status == "inativo":
            usuario.ativo = False
            db.commit()
            return True
            
    return False

async def avancar_jornada(db: Session, usuario_jornada: UsuarioJornada):
    jornada = usuario_jornada.jornada
    etapas = jornada.etapas
    
    if not etapas:
        usuario_jornada.concluida = True
        db.commit()
        return
        
    etapa_atual = usuario_jornada.etapa_atual
    
    if etapa_atual is None:
        proxima_etapa = etapas[0]
    else:
        etapa_index = next((i for i, e in enumerate(etapas) if e.id == etapa_atual.id), -1)
        if etapa_index == -1 or etapa_index == len(etapas) - 1:
            usuario_jornada.concluida = True
            db.commit()
            return
        proxima_etapa = etapas[etapa_index + 1]
        
    sucesso = await executar_acao_workflow(db, usuario_jornada.usuario, proxima_etapa)
    
    if sucesso:
   
(Content truncated due to size limit. Use page ranges or line ranges to read remaining content)