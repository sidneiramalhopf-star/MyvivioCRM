# ============================================================
# MyvivioCRM - Gym & Corporate Wellness Management System
# Sistema de Gestão para Academias e Wellness Corporativo
# Versão Modernizada com IA, Automação e Replit-Ready
# ============================================================

from fastapi import FastAPI, Depends, HTTPException, Header, Request, Response, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse, HTMLResponse
from sqlalchemy import create_engine, Column, Integer, String, Float, Boolean, ForeignKey, DateTime, Text, Index, func
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship, Session
from datetime import datetime, timedelta, timezone
from typing import Optional, List
import jwt
from passlib.context import CryptContext
import os
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
import pickle
import aiosmtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from pydantic import BaseModel

# ============================================================
# Configurações básicas
# ============================================================

# Ajuste para Replit: SQLite é a opção mais simples.
DATABASE_URL = "sqlite:///./gym_wellness.db"
SECRET_KEY = os.getenv("SESSION_SECRET", "gym_wellness_secret_key_CHANGE_IN_PRODUCTION")
ALGORITHM = "HS256"

pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")
security = HTTPBearer()

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# ============================================================
# Modelos de Banco de Dados (SQLAlchemy)
# Mantendo a estrutura original
# ============================================================

class Unidade(Base):
    __tablename__ = "unidades"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String, unique=True)
    endereco = Column(String)
    # Modernização 1: Campo para armazenar o modelo de ML treinado para a unidade
    modelo_churn = Column(Text, nullable=True) 
    risco_desistencia = Column(Float, default=0.0)
    usuarios = relationship("Usuario", back_populates="unidade")
    programas = relationship("Programa", back_populates="unidade")

class Usuario(Base):
    __tablename__ = "usuarios"
    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True)
    senha = Column(String)
    nome = Column(String)
    tipo = Column(String) # admin, instrutor, cliente
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    ativo = Column(Boolean, default=True)
    data_cadastro = Column(DateTime, default=lambda: datetime.now(timezone.utc)) # Correção Replit/Datetime
    ultima_atividade = Column(DateTime, default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc))
    # Modernização 1: Risco de Churn individual
    risco_churn = Column(Float, default=0.0) 
    unidade = relationship("Unidade", back_populates="usuarios")
    agendas = relationship("Agenda", back_populates="usuario")

class Visitante(Base):
    __tablename__ = "visitantes"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String)
    email = Column(String)
    telefone = Column(String)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    data_visita = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    convertido = Column(Boolean, default=False)
    # Modernização 1: Pontuação de Lead
    lead_score = Column(Integer, default=0) 
    unidade = relationship("Unidade")

class Programa(Base):
    __tablename__ = "programas"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String)
    descricao = Column(Text)
    status = Column(String)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    data_inicio = Column(DateTime)
    data_fim = Column(DateTime)
    usuarios_matriculados = Column(Integer, default=0)
    unidade = relationship("Unidade", back_populates="programas")

class Agenda(Base):
    __tablename__ = "agendas"
    id = Column(Integer, primary_key=True, index=True)
    usuario_id = Column(Integer, ForeignKey("usuarios.id"))
    titulo = Column(String)
    descricao = Column(Text)
    data = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    concluida = Column(Boolean, default=False)
    tipo_atividade = Column(String)
    duracao_minutos = Column(Integer)
    usuario = relationship("Usuario", back_populates="agendas")

class EventoAula(Base):
    __tablename__ = "eventos_aulas"
    id = Column(Integer, primary_key=True, index=True)
    nome_aula = Column(String)
    descricao = Column(Text)
    instrutor_id = Column(Integer, ForeignKey("instrutores.id"))
    sala_id = Column(Integer, ForeignKey("salas.id"))
    data_hora = Column(DateTime)
    duracao_minutos = Column(Integer, default=60)
    limite_inscricoes = Column(Integer)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))
    reservas = relationship("ReservaAula", back_populates="evento_aula")

class ReservaAula(Base):
    __tablename__ = "reservas_aulas"
    id = Column(Integer, primary_key=True, index=True)
    evento_aula_id = Column(Integer, ForeignKey("eventos_aulas.id"))
    usuario_id = Column(Integer, ForeignKey("usuarios.id"))
    data_reserva = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    cancelada = Column(Boolean, default=False)
    evento_aula = relationship("EventoAula", back_populates="reservas")
    usuario = relationship("Usuario")

class Instrutor(Base):
    __tablename__ = "instrutores"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String)
    email = Column(String)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))

class Sala(Base):
    __tablename__ = "salas"
    id = Column(Integer, primary_key=True, index=True)
    nome = Column(String)
    capacidade = Column(Integer)
    unidade_id = Column(Integer, ForeignKey("unidades.id"))

# Modernização 5: Tabela de Eventos (Event-Driven)
class EventoSistema(Base):
    __tablename__ = "eventos_sistema"
    id = Column(Integer, primary_key=True, index=True)
    tipo = Column(String) # Ex: RESERVA_CRIADA, CHURN_ALERTA, LEAD_CONVERTIDO
    payload = Column(Text) # JSON com dados do evento
    data_registro = Column(DateTime, default=lambda: datetime.now(timezone.utc))
    processado = Column(Boolean, default=False)

# Outros modelos do código original (Questionario, MetricaEngajamento, etc.) seriam mantidos aqui.
# Para brevidade, focaremos nos modelos essenciais para as novas funcionalidades.

# ============================================================
# Schemas Pydantic (Modernização: Uso de Pydantic para validação)
# ============================================================

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    email: Optional[str] = None

class UsuarioBase(BaseModel):
    email: str
    nome: str
    tipo: str
    unidade_id: int
    ativo: Optional[bool] = True

class UsuarioCreate(UsuarioBase):
    senha: str

class UsuarioUpdate(BaseModel):
    nome: Optional[str] = None
    tipo: Optional[str] = None
    ativo: Optional[bool] = None

class UsuarioInDB(UsuarioBase):
    id: int
    data_cadastro: datetime
    ultima_atividade: datetime
    risco_churn: float

    class Config:
        from_attributes = True

class UnidadeBase(BaseModel):
    nome: str
    endereco: str

class UnidadeCreate(UnidadeBase):
    pass

class UnidadeInDB(UnidadeBase):
    id: int
    risco_desistencia: float

    class Config:
        from_attributes = True

class ReservaCreate(BaseModel):
    evento_aula_id: int

class EventoAulaInDB(BaseModel):
    id: int
    nome_aula: str
    data_hora: datetime
    limite_inscricoes: int

    class Config:
        from_attributes = True

class EventoSistemaInDB(BaseModel):
    id: int
    tipo: str
    payload: str
    data_registro: datetime

    class Config:
        from_attributes = True

# ============================================================
# Funções de Utilitário e Dependências
# ============================================================

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def verify_password(plain_password, hashed_password):
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password):
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=30)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security), db: Session = Depends(get_db)):
    try:
        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[ALGORITHM])
        email: str = payload.get("sub")
        if email is None:
            raise HTTPException(status_code=401, detail="Credenciais inválidas")
        token_data = TokenData(email=email)
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Credenciais inválidas")
    
    user = db.query(Usuario).filter(Usuario.email == token_data.email).first()
    if user is None:
        raise HTTPException(status_code=401, detail="Usuário não encontrado")
    return user

def get_admin_user(current_user: Usuario = Depends(get_current_user)):
    if current_user.tipo != "admin":
        raise HTTPException(status_code=403, detail="Acesso negado. Requer privilégios de administrador.")
    return current_user

# Modernização 3: Função de Envio de E-mail (Omnichannel)
async def enviar_email(destinatario: str, assunto: str, corpo: str):
    # Mantendo a função original, mas destacando a necessidade de expansão para Omnichannel
    smtp_host = os.getenv("SMTP_HOST", "smtp.gmail.com")
    smtp_port = int(os.getenv("SMTP_PORT", "587"))
    smtp_user = os.getenv("SMTP_USER", "noreply@myvivio.com")
    smtp_pass = os.getenv("SMTP_PASSWORD", "")
    
    message = MIMEMultipart()
    message["From"] = smtp_user
    message["To"] = destinatario
    message["Subject"] = assunto
    message.attach(MIMEText(corpo, "html"))
    
    try:
        if smtp_pass:
            await aiosmtplib.send(
                message,
                hostname=smtp_host,
                port=smtp_port,
                username=smtp_user,
                password=smtp_pass,
                start_tls=True
            )
            return True
        return False
    except Exception as e:
        print(f"Erro ao enviar e-mail: {e}")
        return False

# Modernização 5: Função para registrar eventos (Event-Driven)
def registrar_evento(db: Session, tipo: str, payload: dict):
    evento = EventoSistema(
        tipo=tipo,
        payload=str(payload) # Simples serialização para Text
    )
    db.add(evento)
    db.commit()
    db.refresh(evento)
    return evento

# ============================================================
# Modernização 4: Lógica de Automação (Processamento de Eventos)
# ============================================================

async def processar_eventos(db: Session):
    """
    Processa eventos pendentes no sistema.
    Modernização 2: Automação de Fluxos de Trabalho
    """
    eventos = db.query(EventoSistema).filter(EventoSistema.processado == False).all()
    
    for evento in eventos:
        try:
            if evento.tipo == "RESERVA_CRIADA":
                payload = eval(evento.payload) # Deserialização simples
                usuario = db.query(Usuario).get(payload.get("usuario_id"))
                aula = db.query(EventoAula).get(payload.get("evento_aula_id"))
                
                if usuario and aula:
                    assunto = f"Confirmação de Reserva: {aula.nome_aula}"
                    corpo = f"Olá {usuario.nome}, sua reserva para a aula '{aula.nome_aula}' em {aula.data_hora.strftime('%d/%m/%Y %H:%M')} foi confirmada."
                    await enviar_email(usuario.email, assunto, corpo)
                    print(f"E-mail de confirmação enviado para {usuario.email}")

            elif evento.tipo == "CHURN_ALERTA":
                payload = eval(evento.payload)
                usuario = db.query(Usuario).get(payload.get("usuario_id"))
                
                if usuario:
                    # Modernização 2: Disparar fluxo de reengajamento
                    assunto = "Alerta de Risco de Desistência"
                    corpo = f"O usuário {usuario.nome} ({usuario.email}) atingiu um risco de churn de {usuario.risco_churn:.2f}. Ação de reengajamento necessária!"
                    await enviar_email("admin@myvivio.com", assunto, corpo)
                    print(f"Alerta de Churn enviado para o Admin.")

            # Outros tipos de eventos (LEAD_CONVERTIDO, etc.) seriam processados aqui.
            
            evento.processado = True
            db.commit()
        except Exception as e:
            print(f"Erro ao processar evento {evento.id}: {e}")
            db.rollback()

# ============================================================
# Modernização 1: Lógica de IA/ML (Previsão de Churn)
# ============================================================

def treinar_modelo_churn(db: Session, unidade_id: int):
    """
    Treina um modelo de Regressão Logística para prever Churn.
    Dados de exemplo: dias desde a última atividade, número de reservas canceladas, etc.
    """
    # 1. Coletar dados (Simulação)
    # Na vida real, isso envolveria dados históricos de engajamento, frequência, cancelamentos, etc.
    usuarios = db.query(Usuario).filter(Usuario.unidade_id == unidade_id).all()
    
    data = []
    for u in usuarios:
        dias_inatividade = (datetime.now(timezone.utc) - u.ultima_atividade).days
        reservas_canceladas = db.query(ReservaAula).filter(
            ReservaAula.usuario_id == u.id,
            ReservaAula.cancelada == True
        ).count()
        
        # Variável alvo (simulação): Churn se inativo por mais de 60 dias E cancelou mais de 5 reservas
        churn = 1 if dias_inatividade > 60 and reservas_canceladas > 5 else 0
        
        data.append({
            'dias_inatividade': dias_inatividade,
            'reservas_canceladas': reservas_canceladas,
            'churn': churn,
            'usuario_id': u.id
        })
    
    if not data or len(data) < 10:
        return "Dados insuficientes para treinamento."

    df = pd.DataFrame(data)
    
    # 2. Treinamento
    X = df[['dias_inatividade', 'reservas_canceladas']]
    y = df['churn']
    
    model = LogisticRegression()
    model.fit(X, y)
    
    # 3. Serializar e Salvar o Modelo
    modelo_serializado = pickle.dumps(model)
    unidade = db.query(Unidade).get(unidade_id)
    unidade.modelo_churn = modelo_serializado
    db.commit()
    
    return "Modelo treinado e salvo com sucesso."

def prever_risco_churn(db: Session, usuario: Usuario):
    """
    Usa o modelo treinado para prever o risco de churn de um usuário.
    """
    unidade = db.query(Unidade).get(usuario.unidade_id)
    if not unidade or not unidade.modelo_churn:
        return 0.0 # Retorna 0 se não houver modelo

    try:
        model = pickle.loads(unidade.modelo_churn.encode('latin1')) # Deserialização
    except:
        return 0.0

    dias_inatividade = (datetime.now(timezone.utc) - usuario.ultima_atividade).days
    reservas_canceladas = db.query(ReservaAula).filter(
        ReservaAula.usuario_id == usuario.id,
        ReservaAula.cancelada == True
    ).count()
    
    # Previsão de probabilidade de churn (risco)
    risco = model.predict_proba([[dias_inatividade, reservas_canceladas]])[0][1]
    
    # Atualiza o campo no banco de dados
    usuario.risco_churn = risco
    db.commit()
    
    # Modernização 2: Disparar alerta se o risco for alto
    if risco > 0.75:
        registrar_evento(db, "CHURN_ALERTA", {"usuario_id": usuario.id, "risco": risco})
        
    return risco

# ============================================================
# Inicialização do FastAPI e Criação das Tabelas
# ============================================================

app = FastAPI(
    title="MyvivioCRM Modernizado",
    description="Backend FastAPI para Gestão de Wellness com IA e Automação."
)

# Configuração CORS (necessário para Replit/Frontend)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # Permitir todas as origens para desenvolvimento no Replit
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Criação das tabelas no startup
@app.on_event("startup")
def startup_event():
    Base.metadata.create_all(bind=engine)
    print("Tabelas do banco de dados criadas/verificadas.")

# ============================================================
# Endpoints de Autenticação (Mantendo a lógica original)
# ============================================================

@app.post("/token", response_model=Token)
def login_for_access_token(email: str, senha: str, db: Session = Depends(get_db)):
    user = db.query(Usuario).filter(Usuario.email == email).first()
    if not user or not verify_password(senha, user.senha):
        raise HTTPException(
            status_code=400,
            detail="Email ou senha incorretos",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=30)
    access_token = create_access_token(
        data={"sub": user.email}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@app.get("/users/me/", response_model=UsuarioInDB)
def read_users_me(current_user: Usuario = Depends(get_current_user)):
    return current_user

# ============================================================
# Endpoints de Reservas (Modernização 5: Event-Driven)
# ============================================================

@app.post("/aulas/{aula_id}/reservar")
def reservar_aula(
    aula_id: int,
    usuario: Usuario = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    aula = db.query(EventoAula).filter(EventoAula.id == aula_id).first()
    if not aula:
        raise HTTPException(status_code=404, detail="Aula não encontrada")
    
    # Lógica de validação de vagas e duplicidade (mantida)
    # ...
    
    reserva = ReservaAula(evento_aula_id=aula_id, usuario_id=usuario.id)
    db.add(reserva)
    db.commit()
    db.refresh(reserva)
    
    # Modernização 5: Registrar Evento
    registrar_evento(db, "RESERVA_CRIADA", {
        "reserva_id": reserva.id,
        "usuario_id": usuario.id,
        "evento_aula_id": aula_id
    })
    
    return {"mensagem": "Reserva realizada com sucesso!", "id": reserva.id}

# ============================================================
# Endpoints de Modernização (IA/ML)
# ============================================================

@app.post("/admin/ia/treinar_churn/{unidade_id}")
def endpoint_treinar_churn(unidade_id: int, admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Endpoint para treinar o modelo de previsão de Churn para uma unidade. """
    resultado = treinar_modelo_churn(db, unidade_id)
    return {"mensagem": resultado}

@app.get("/usuarios/{usuario_id}/risco_churn")
def endpoint_risco_churn(usuario_id: int, admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Endpoint para obter e atualizar o risco de churn de um usuário. """
    usuario = db.query(Usuario).get(usuario_id)
    if not usuario:
        raise HTTPException(status_code=404, detail="Usuário não encontrado")
    
    risco = prever_risco_churn(db, usuario)
    return {"usuario_id": usuario_id, "risco_churn": risco}

# ============================================================
# Endpoints do PAINEL (Relatórios e CSV) - Modernização 2
# ============================================================

@app.get("/painel/relatorio_usuarios")
def relatorio_usuarios(admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Retorna um relatório básico de usuários. """
    usuarios = db.query(Usuario).all()
    
    # Modernização 2: Uso de Pandas para manipulação de dados
    data = [{
        "id": u.id,
        "nome": u.nome,
        "email": u.email,
        "tipo": u.tipo,
        "unidade_id": u.unidade_id,
        "risco_churn": u.risco_churn
    } for u in usuarios]
    
    return {"total_usuarios": len(data), "dados": data}

@app.get("/painel/exportar_usuarios_csv")
def exportar_usuarios_csv(admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Exporta dados de usuários para CSV. """
    usuarios = db.query(Usuario).all()
    
    data = [{
        "ID": u.id,
        "Nome": u.nome,
        "Email": u.email,
        "Tipo": u.tipo,
        "Unidade_ID": u.unidade_id,
        "Risco_Churn": u.risco_churn,
        "Data_Cadastro": u.data_cadastro.isoformat()
    } for u in usuarios]
    
    df = pd.DataFrame(data)
    csv_path = "/tmp/usuarios_export.csv"
    df.to_csv(csv_path, index=False)
    
    return FileResponse(
        path=csv_path,
        filename="usuarios_myviviocrm.csv",
        media_type="text/csv"
    )

# ============================================================
# Endpoints de CONFIGURAÇÃO (Admin)
# ============================================================

@app.post("/configuracao/unidades", response_model=UnidadeInDB)
def criar_unidade(unidade: UnidadeCreate, admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Cria uma nova unidade. """
    db_unidade = Unidade(**unidade.model_dump())
    db.add(db_unidade)
    db.commit()
    db.refresh(db_unidade)
    return db_unidade

@app.post("/configuracao/usuarios", response_model=UsuarioInDB)
def criar_usuario(usuario: UsuarioCreate, admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Cria um novo usuário (Admin pode criar outros tipos). """
    hashed_password = get_password_hash(usuario.senha)
    db_usuario = Usuario(
        email=usuario.email,
        senha=hashed_password,
        nome=usuario.nome,
        tipo=usuario.tipo,
        unidade_id=usuario.unidade_id
    )
    db.add(db_usuario)
    db.commit()
    db.refresh(db_usuario)
    return db_usuario

@app.put("/configuracao/usuarios/{usuario_id}", response_model=UsuarioInDB)
def atualizar_usuario(usuario_id: int, usuario_update: UsuarioUpdate, admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Atualiza informações de um usuário. """
    db_usuario = db.query(Usuario).filter(Usuario.id == usuario_id).first()
    if not db_usuario:
        raise HTTPException(status_code=404, detail="Usuário não encontrado")
    
    update_data = usuario_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_usuario, key, value)
        
    db.commit()
    db.refresh(db_usuario)
    return db_usuario

# ============================================================
# Modernização 4: Endpoint de Processamento de Eventos (Automação)
# Na prática, isso seria um worker rodando em background, mas para o Replit/teste, é um endpoint.
# ============================================================

@app.post("/admin/processar_automacao")
async def run_automacao(admin: Usuario = Depends(get_admin_user), db: Session = Depends(get_db)):
    """ Executa o processamento de eventos pendentes. """
    await processar_eventos(db)
    return {"mensagem": "Processamento de automação concluído."}

# ============================================================
# Execução para Replit
# ============================================================

if __name__ == "__main__":
    import uvicorn
    # O Replit expõe a porta 8080 para aplicações web
    uvicorn.run("main:app", host="0.0.0.0", port=8080, reload=True)
